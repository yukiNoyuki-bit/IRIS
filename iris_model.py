# -*- coding: utf-8 -*-
"""IRIS_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ogoioQ4j9yM4anac3-b8wlvYa5lA-CnG
"""

import os, zipfile, random, math
import numpy as np
import pandas as pd

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

from sklearn.ensemble import RandomForestClassifier
from sklearn.multioutput import MultiOutputRegressor
from sklearn.ensemble import ExtraTreesRegressor

import matplotlib.pyplot as plt
from IPython.display import display, clear_output

import joblib

RANDOM_STATE = 42
np.random.seed(RANDOM_STATE)
random.seed(RANDOM_STATE)


DATA_DIR = os.getcwd()

CANDIDATE_DIRS = [
    DATA_DIR,
    "/content",
    "/mnt/data"
]

def resolve_file(filename):
    if os.path.exists(filename):
        return filename
    for d in CANDIDATE_DIRS:
        p = os.path.join(d, filename)
        if os.path.exists(p):
            return p
    for d in CANDIDATE_DIRS:
        if os.path.isdir(d):
            for root, _, files in os.walk(d):
                if filename in files:
                    return os.path.join(root, filename)
    raise FileNotFoundError(f"File '{filename}' tidak ditemukan. Pastikan sudah upload/tersedia di folder notebook atau /content (Colab).")

CSV_CLASSIFY = resolve_file("tomato_sensor_multiclass_12000.csv")
CSV_TIMESERIES = resolve_file("dummy_tomato_sensor_dataset_7days_10min.csv")
CSV_IRRIG = None
try:
    CSV_IRRIG = resolve_file("2.Tomato_Irrigation_Dataset.csv")
except FileNotFoundError:
    CSV_IRRIG = None

ZIP_EXPRESSIONS = None
try:
    ZIP_EXPRESSIONS = resolve_file("expresi_tanaman_dataset.zip")
except FileNotFoundError:
    ZIP_EXPRESSIONS = None

EXP_DIR = os.path.join(DATA_DIR, "expresi_tanaman_dataset_extracted")

"""## 1) Load dataset CSV + standarisasi kolom"""

# 1) Load dataset CSV + standarisasi kolom
def load_csv_safe(path):
    if not os.path.exists(path):
        raise FileNotFoundError(f"Tidak ditemukan: {path}")
    return pd.read_csv(path)

df_cls = load_csv_safe(CSV_CLASSIFY)
df_ts  = load_csv_safe(CSV_TIMESERIES)

print("df_cls:", df_cls.shape, "cols:", list(df_cls.columns))
print("df_ts :", df_ts.shape,  "cols:", list(df_ts.columns))

for df in [df_cls, df_ts]:
    if "timestamp" in df.columns:
        df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
        df.sort_values("timestamp", inplace=True)
        df.reset_index(drop=True, inplace=True)

SENSOR_COLS = ["air_humidity_pct", "soil_moisture_pct", "air_temperature_c", "light_intensity_lux", "uv_index"]

missing_cls = [c for c in SENSOR_COLS if c not in df_cls.columns]
missing_ts  = [c for c in SENSOR_COLS if c not in df_ts.columns]
if missing_cls:
    raise ValueError(f"Kolom sensor wajib tidak ada di df_cls: {missing_cls}")
if missing_ts:
    raise ValueError(f"Kolom sensor wajib tidak ada di df_ts: {missing_ts}")

# ============================================================
# Auto-label (Tomat Indoor) sesuai threshold Flutter Anda
# Ini yang akan dipakai untuk MELATIH model klasifikasi.
# ============================================================

def suhu_ket_tomat_indoor(t: float) -> str:
    if pd.isna(t): return "-"
    t = float(t)
    if t < 13: return "Dingin"
    if t < 18: return "Sejuk"
    if t <= 27: return "Optimal"
    if t <= 30: return "Hangat"
    if t <= 33: return "Panas"
    return "Bahaya panas"

def rh_ket_tomat_indoor(rh: float) -> str:
    if pd.isna(rh): return "-"
    rh = float(rh)
    if rh < 40: return "Terlalu kering"
    if rh < 55: return "Agak kering"
    if rh <= 75: return "Optimal"
    if rh <= 85: return "Terlalu lembap"
    return "Sangat lembap (risiko jamur)"

def soil_ket_tomat_indoor(sm: float) -> str:
    if pd.isna(sm): return "-"
    sm = float(sm)
    if sm < 30: return "Kering (butuh air)"
    if sm < 40: return "Agak kering"
    if sm <= 70: return "Optimal"
    if sm <= 85: return "Basah (kurangi air)"
    return "Terlalu basah (risiko busuk akar)"

def lux_ket(lux: float) -> str:
    if pd.isna(lux): return "-"
    lux = float(lux)
    if lux < 200: return "Rendah"
    if lux < 600: return "Sedang"
    if lux < 900: return "Tinggi"
    return "Sangat tinggi"

def uv_ket(uv: float) -> str:
    if pd.isna(uv): return "-"
    uv = float(uv)
    if uv <= 2: return "Rendah"
    if uv <= 5: return "Sedang"
    if uv <= 7: return "Tinggi"
    if uv <= 10: return "Sangat tinggi"
    return "Ekstrem"

# Target label per-sensor (multi-output)
TARGET_LABEL_COLS = ["label_suhu", "label_rh", "label_soil", "label_lux", "label_uv"]

df_cls["label_suhu"] = df_cls["air_temperature_c"].apply(suhu_ket_tomat_indoor)
df_cls["label_rh"]   = df_cls["air_humidity_pct"].apply(rh_ket_tomat_indoor)
df_cls["label_soil"] = df_cls["soil_moisture_pct"].apply(soil_ket_tomat_indoor)
df_cls["label_lux"]  = df_cls["light_intensity_lux"].apply(lux_ket)
df_cls["label_uv"]   = df_cls["uv_index"].apply(uv_ket)

print("\nContoh hasil auto-label (5 baris):")
display(df_cls[SENSOR_COLS + TARGET_LABEL_COLS].head())

print("\nDistribusi label (ringkas):")
for c in TARGET_LABEL_COLS:
    print(f"- {c}: {df_cls[c].value_counts().to_dict()}")

"""## 2) Ekstrak dataset ekspresi (animasi kondisi tanaman)"""

# 2) Ekstrak dataset ekspresi (animasi kondisi tanaman)
if ZIP_EXPRESSIONS and os.path.exists(ZIP_EXPRESSIONS):
    if not os.path.exists(EXP_DIR):
        os.makedirs(EXP_DIR, exist_ok=True)
        with zipfile.ZipFile(ZIP_EXPRESSIONS, "r") as zf:
            zf.extractall(EXP_DIR)
    print("Expression dataset extracted to:", EXP_DIR)
else:
    print("ZIP ekspresi tidak tersedia. Demo tetap jalan, hanya tanpa gambar ekspresi.")
    print("Pastikan file 'expresi_tanaman_dataset.zip' berada di folder notebook (atau /content di Colab).")

train_root = os.path.join(EXP_DIR, "expresi_tanaman_dataset", "train")
print("train_root exists:", os.path.exists(train_root))
if os.path.exists(train_root):
    classes = sorted([d for d in os.listdir(train_root) if os.path.isdir(os.path.join(train_root, d))])
    print("Expression classes:", classes)

def pick_expression_image(expr_class, default=None):
    """Ambil 1 gambar random dari kelas ekspresi. Return path atau default."""
    folder = os.path.join(train_root, expr_class)
    if not os.path.exists(folder):
        return default
    imgs = [os.path.join(folder, f) for f in os.listdir(folder) if f.lower().endswith((".jpg",".jpeg",".png"))]
    if not imgs:
        return default
    return random.choice(imgs)

sample = pick_expression_image("happy")
if sample:
    img = plt.imread(sample)
    plt.figure(figsize=(3,3))
    plt.imshow(img)
    plt.axis("off")
    plt.title("Sample expression: happy")
    plt.show()

"""## 3) Model-1: Keputusan Sekarang (Multiclass Classification)
Kita latih model klasifikasi dari `tomato_sensor_multiclass_12000.csv` untuk memprediksi label kondisi tanaman berdasarkan 5 sensor.

Label contoh di dataset Anda (tergantung isi CSV): `SEHAT`, `KURANG_AIR`, `STRES_PANAS`, `UV_TINGGI`, dll.
"""

# 3) Model-1: Keputusan Sekarang (Multiclass Classification)

# ============================
# Model-1: Klasifikasi status per-sensor (multi-output)
# Output: 5 label sekaligus (suhu, RH, soil, lux, UV)
# ============================

X = df_cls[SENSOR_COLS].values.astype(float)
y = df_cls[TARGET_LABEL_COLS].astype(str)

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=RANDOM_STATE, shuffle=True
)

base_est = RandomForestClassifier(
    n_estimators=500,
    random_state=RANDOM_STATE,
    class_weight="balanced_subsample",
    n_jobs=-1,
    max_depth=None,
    min_samples_leaf=2
)

clf = MultiOutputClassifier(base_est)
clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)

# Evaluasi
print("=== Evaluasi Multi-Output ===")
overall_exact_match = np.mean(np.all(y_pred == y_test.values, axis=1))
print("Exact Match Ratio (semua label benar sekaligus):", round(float(overall_exact_match), 4))

for i, col in enumerate(TARGET_LABEL_COLS):
    acc = accuracy_score(y_test.iloc[:, i].values, y_pred[:, i])
    print(f"- Accuracy {col}: {round(float(acc), 4)}")
    print(classification_report(y_test.iloc[:, i].values, y_pred[:, i]))

"""## 4) Model-2: Prediksi Kelembapan Tanah (Forecast beberapa jam ke depan)
Tujuan: dari data time-series 10 menit, kita membuat model untuk memprediksi **soil_moisture_pct** untuk beberapa jam ke depan.

Model yang digunakan: **ExtraTreesRegressor (MultiOutput)** berbasis fitur lag (window waktu). Model ini stabil dan ringan untuk Colab/Jupyter tanpa GPU.
"""

# 4) Model-2: Prediksi Kelembapan Tanah (Forecast beberapa jam ke depan)
FREQ_MINUTES = 10
PAST_HOURS = 6
FORECAST_HOURS = 6
W = int(PAST_HOURS*60/FREQ_MINUTES)
H = int(FORECAST_HOURS*60/FREQ_MINUTES)
TARGET_COL = "soil_moisture_pct"

def make_supervised_forecast(df, sensor_cols, target_col, window=W, horizon=H):
    """Ubah time series menjadi supervised dataset (X lag window, y multi-step horizon)."""
    values = df[sensor_cols].values.astype(float)
    target = df[target_col].values.astype(float)

    X_list, y_list = [], []
    for t in range(window, len(df) - horizon):
        x = values[t-window:t].reshape(-1)
        y = target[t:t+horizon]
        X_list.append(x)
        y_list.append(y)
    Xs = np.array(X_list)
    ys = np.array(y_list)
    return Xs, ys

Xf, yf = make_supervised_forecast(df_ts, SENSOR_COLS, TARGET_COL, window=W, horizon=H)
print("Forecast supervised X:", Xf.shape, "y:", yf.shape)

split_idx = int(len(Xf) * 0.8)
Xf_train, Xf_test = Xf[:split_idx], Xf[split_idx:]
yf_train, yf_test = yf[:split_idx], yf[split_idx:]

forecaster = Pipeline(steps=[
    ("scaler", StandardScaler()),
    ("model", MultiOutputRegressor(
        ExtraTreesRegressor(
            n_estimators=300,
            random_state=RANDOM_STATE,
            n_jobs=-1,
            min_samples_leaf=2
        )
    ))
])

forecaster.fit(Xf_train, yf_train)
pred_test = forecaster.predict(Xf_test)
mae = np.mean(np.abs(pred_test - yf_test))
print("Mean Absolute Error (avg over horizon):", round(mae, 4))

i = 0
plt.figure(figsize=(10,4))
plt.plot(yf_test[i], label="actual")
plt.plot(pred_test[i], label="pred")
plt.title("Contoh prediksi soil moisture (next {} steps = {} jam)".format(H, FORECAST_HOURS))
plt.xlabel("step (10 min)")
plt.ylabel("soil_moisture_pct")
plt.legend()
plt.show()

"""## 5) Aturan interpretasi (Keputusan AI + Prediksi Siram + Laju Penguapan)
Agar output lebih "aplikatif" (bukan hanya label mentah), kita buat *post-processing*:
- **Keputusan AI**: hasil klasifikasi multiclass + heuristik untuk aksi.
- **Prediksi Siram**: estimasi kapan soil moisture turun melewati ambang.
- **Laju Penguapan**: estimasi laju penurunan soil moisture per hari (berdasarkan tren 24 jam terakhir).
"""

# 5) Aturan interpretasi (Keputusan AI + Prediksi Siram + Laju Penguapan)
def decide_action_from_labels(labels: dict) -> str:
    """
    labels: dict dengan key:
      label_suhu, label_rh, label_soil, label_lux, label_uv
    Return: aksi/alert ringkas untuk aplikasi.
    """
    soil = labels.get("label_soil", "-")
    suhu = labels.get("label_suhu", "-")
    rh   = labels.get("label_rh", "-")
    uv   = labels.get("label_uv", "-")

    if soil == "Kering (butuh air)":
        return "SIRAM_SEKARANG"
    if soil == "Agak kering":
        return "SIAGA_SIRAM"
    if soil in ["Basah (kurangi air)", "Terlalu basah (risiko busuk akar)"]:
        return "KURANGI_SIRAM"

    if suhu in ["Panas", "Bahaya panas"]:
        return "WASPADA_PANAS"
    if rh in ["Sangat lembap (risiko jamur)"]:
        return "RISIKO_JAMUR"
    if uv in ["Sangat tinggi", "Ekstrem"]:
        return "WASPADA_UV"

    return "AMAN"

def decision_to_expression(decision: str) -> str:
    """Pemetaan keputusan -> kelas ekspresi untuk animasi."""
    if decision == "AMAN":
        return "happy"
    if decision in ["SIAGA_SIRAM", "KURANGI_SIRAM"]:
        return "tired" if os.path.exists(os.path.join(train_root, "tired")) else "sad_cry"
    if decision == "SIRAM_SEKARANG":
        return "water_splash" if os.path.exists(os.path.join(train_root, "water_splash")) else "sad_cry"
    if decision in ["WASPADA_PANAS", "WASPADA_UV"]:
        return "hot" if os.path.exists(os.path.join(train_root, "hot")) else "sad_cry"
    if decision == "RISIKO_JAMUR":
        return "sick" if os.path.exists(os.path.join(train_root, "sick")) else "sad_cry"
    return "sad_cry"

def soil_ket_tomat_indoor(sm: float) -> str:
    if pd.isna(sm): return "-"
    sm = float(sm)
    if sm < 30: return "Kering (butuh air)"
    if sm < 40: return "Agak kering"
    if sm <= 70: return "Optimal"
    if sm <= 85: return "Basah (kurangi air)"
    return "Terlalu basah (risiko busuk akar)"

def estimate_next_irrigation_hours(soil_forecast, threshold=30.0):
    """Estimasi berapa jam lagi soil moisture melewati threshold (default 30)."""
    idx = np.where(np.array(soil_forecast) <= threshold)[0]
    if len(idx) == 0:
        return None
    first = int(idx[0])
    minutes = (first + 1) * FREQ_MINUTES
    return minutes / 60.0

def future_decision_timeline(soil_forecast):
    """Timeline keputusan berbasis prediksi soil moisture (mengikuti label soil)."""
    timeline = []
    for v in soil_forecast:
        s = soil_ket_tomat_indoor(v)
        if s == "Kering (butuh air)":
            timeline.append("SIRAM_SEKARANG")
        elif s == "Agak kering":
            timeline.append("SIAGA_SIRAM")
        elif s in ["Basah (kurangi air)", "Terlalu basah (risiko busuk akar)"]:
            timeline.append("KURANGI_SIRAM")
        else:
            timeline.append("AMAN")
    return timeline

"""## 5.1 API Inferensi (untuk integrasi realtime)
Jika nanti data sensor datang dari ESP32/Firebase, gunakan fungsi di bawah ini.
Anda cukup menyimpan **history window W langkah terakhir** (misalnya list/array 36 baris) lalu panggil `predict_once(...)`.
"""

from collections import deque

class SmartFarmingPredictor:
    def __init__(self, decision_model, forecast_model, sensor_cols, target_label_cols, window=W):
        self.decision_model = decision_model
        self.forecast_model = forecast_model
        self.sensor_cols = sensor_cols
        self.target_label_cols = target_label_cols
        self.window = window
        self.history = deque(maxlen=window)

    def add_reading(self, reading: dict):
        """reading: dict berisi 5 sensor sesuai sensor_cols."""
        self.history.append([float(reading[c]) for c in self.sensor_cols])

    def ready(self):
        return len(self.history) >= self.window

    def forecast_soil(self):
        """Prediksi soil moisture beberapa jam ke depan (butuh window histori)."""
        if not self.ready():
            return None
        x = np.array(self.history, dtype=float).reshape(1, -1)
        pred = self.forecast_model.predict(x)[0]
        return pred.tolist()

    def predict_once(self, current_row: dict):
        """
        Return:
          - labels_now: label per-sensor (sesuai threshold Flutter)
          - decision: aksi/alert (aman/siaga/siram/waspada)
          - soil_future: list prediksi soil (numeric)
          - timeline: list keputusan future per-step (H langkah)
          - next_irrig_hours: estimasi jam ke threshold
        """

        x_now = np.array([[float(current_row[c]) for c in self.sensor_cols]], dtype=float)
        pred_arr = self.decision_model.predict(x_now)[0]
        labels_now = dict(zip(self.target_label_cols, [str(v) for v in pred_arr]))


        decision = decide_action_from_labels(labels_now)

        if not self.ready():
            return {
                "labels_now": labels_now,
                "decision": decision,
                "soil_future": None,
                "timeline": None,
                "next_irrig_hours": None,
                "note": f"History belum cukup. Butuh {self.window} data (10 menit) untuk forecast.",
            }

        soil_future = self.forecast_soil()
        next_irrig_hours = estimate_next_irrigation_hours(soil_future, threshold=30.0)
        timeline = future_decision_timeline(soil_future)

        return {
            "labels_now": labels_now,
            "decision": decision,
            "soil_future": soil_future,
            "timeline": timeline,
            "next_irrig_hours": next_irrig_hours,
        }

"""## 6) Demo Realtime + Animasi Ekspresi Tanaman
Bagian ini mensimulasikan data sensor masuk per 10 menit (menggunakan `df_ts`).

Anda bisa mempercepat animasi dengan mengubah `DEMO_STEPS` dan `SLEEP_SEC`.
"""

import time
PLANTING_DATE = df_ts["timestamp"].min() - pd.Timedelta(days=40)

def plant_age_days(ts):
    return int((ts - PLANTING_DATE).days)

def show_expression(img_path, title=None):
    if img_path is None or (not os.path.exists(img_path)):
        return
    img = plt.imread(img_path)
    plt.figure(figsize=(3.2, 3.2))
    plt.imshow(img)
    plt.axis("off")
    if title:
        plt.title(title)
    plt.show()


predictor = SmartFarmingPredictor(
    decision_model=clf,
    forecast_model=forecaster,
    sensor_cols=SENSOR_COLS,
    target_label_cols=TARGET_LABEL_COLS,
    window=W
)

seed_n = W
for i in range(seed_n):
    r = df_ts.iloc[i]
    predictor.add_reading({c: r[c] for c in SENSOR_COLS})

start_idx = seed_n
end_idx = min(start_idx + 30, len(df_ts))

print("=== DEMO REALTIME (10 menit per step) ===")
for i in range(start_idx, end_idx):
    row = df_ts.iloc[i].copy()
    ts_now = row["timestamp"] if "timestamp" in row.index else pd.Timestamp.now()


    predictor.add_reading({c: row[c] for c in SENSOR_COLS})

    out = predictor.predict_once(row.to_dict())
    labels_now = out["labels_now"]
    decision = out["decision"]


    expr_cls = decision_to_expression(decision)
    img_path = None
    if os.path.exists(EXP_DIR):
        cand = os.path.join(EXP_DIR, expr_cls)
        if os.path.isdir(cand):
            files = [f for f in os.listdir(cand) if f.lower().endswith((".png",".jpg",".jpeg"))]
            if files:
                img_path = os.path.join(cand, random.choice(files))


    age = plant_age_days(ts_now)
    print("==================================================")
    print(f"üïí Update Terakhir : {ts_now}")
    print(f"üå± Umur Tanaman    : {age} Hari")
    print("--------------------------------------------------")
    print(f"üå°Ô∏è Suhu Udara      : {row['air_temperature_c']:.1f}¬∞C  ({labels_now['label_suhu']})")
    print(f"üíß Kelembapan Udara: {row['air_humidity_pct']:.1f}%   ({labels_now['label_rh']})")
    print(f"ü™¥ Kelembapan Tanah: {row['soil_moisture_pct']:.1f}%  ({labels_now['label_soil']})")
    print(f"üí° Cahaya         : {row['light_intensity_lux']:.0f} lux ({labels_now['label_lux']})")
    print(f"‚òÄÔ∏è UV Index       : {row['uv_index']:.1f}     ({labels_now['label_uv']})")
    print("--------------------------------------------------")
    print(f"ü§ñ Keputusan AI    : {decision}")

    if out["next_irrig_hours"] is not None:
        print(f"‚è≥ Estimasi <30%   : {out['next_irrig_hours']:.2f} jam lagi")

    show_expression(img_path, title=f"{expr_cls} | {decision}")

    time.sleep(0.05)

"""## 7) Simpan model (untuk integrasi ke aplikasi / Firebase / backend)
File yang disimpan:
- `tomato_decision_model.joblib` (klasifikasi kondisi)
- `tomato_forecast_model.joblib` (forecast soil moisture)

Anda bisa upload file ini ke storage/back-end dan dipanggil saat inferensi.
"""

OUT_DIR = os.path.join(DATA_DIR, "export_models")
os.makedirs(OUT_DIR, exist_ok=True)

clf_path = os.path.join(OUT_DIR, "2tomato_decision_multilabel_model.joblib")
fc_path  = os.path.join(OUT_DIR, "2tomato_forecast_model.joblib")

joblib.dump({
    "model": clf,
    "sensor_cols": SENSOR_COLS,
    "target_label_cols": TARGET_LABEL_COLS,
    "label_scheme": "tomat_indoor_flutter_threshold_v1",
}, clf_path)

joblib.dump({
    "model": forecaster,
    "sensor_cols": SENSOR_COLS,
    "target_col": TARGET_COL,
    "window": W,
    "horizon": H,
    "freq_minutes": FREQ_MINUTES,
}, fc_path)

print("Saved:")
print(" -", clf_path)
print(" -", fc_path)

"""## 8) (Opsional) Analisis tambahan dari dataset agronomi (ET)
Jika Anda ingin mengaitkan prediksi dengan konsep agronomi (evapotranspirasi, radiasi surya, dsb.), dataset `2.Tomato_Irrigation_Dataset.csv` bisa dipakai di sini.
Bagian ini tidak wajib untuk demo realtime 5 sensor, tetapi berguna untuk laporan akademik.
"""

if CSV_IRRIG and os.path.exists(CSV_IRRIG):
    df_ir = pd.read_csv(CSV_IRRIG)
    print("df_irrig:", df_ir.shape)
    display(df_ir.head())
    cols = ["temperature","humidity","soil_moisture","evapotranspiration","solar_radiation_ghi","days_of_planted"]
    cols = [c for c in cols if c in df_ir.columns]
    corr = df_ir[cols].corr(numeric_only=True)
    display(corr)
else:
    print("CSV agronomi (2.Tomato_Irrigation_Dataset.csv) tidak tersedia, skip.")

from google.colab import drive
drive.mount('/content/drive')

!cp -r /content/export_models "/content/drive/MyDrive/export_models3"
!ls -lah "/content/drive/MyDrive/export_models3"

import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.multioutput import MultiOutputClassifier
from sklearn.metrics import accuracy_score

base = RandomForestClassifier(n_estimators=500, random_state=42, n_jobs=-1, class_weight="balanced")
mo = MultiOutputClassifier(base)
mo.fit(X_train, y_train)

y_pred = mo.predict(X_test)

accs = {}
for i, col in enumerate(y_test.columns):
    accs[col] = accuracy_score(y_test[col].values, y_pred[:, i])

plt.figure(figsize=(9,4))
plt.bar(list(accs.keys()), list(accs.values()))
plt.title("Accuracy per Target (MultiOutput Random Forest)")
plt.ylabel("accuracy")
plt.ylim(0, 1.05)
plt.xticks(rotation=30, ha="right")
plt.grid(True, axis="y", alpha=0.3)
plt.tight_layout()
plt.show()

n_list = [50, 100, 200, 300, 500, 800]
avg_test = []

for n in n_list:
    base = RandomForestClassifier(n_estimators=n, random_state=42, n_jobs=-1, class_weight="balanced")
    m = MultiOutputClassifier(base)
    m.fit(X_train, y_train)
    yp = m.predict(X_test)

    per_target = []
    for i, col in enumerate(y_test.columns):
        per_target.append(accuracy_score(y_test[col].values, yp[:, i]))
    avg_test.append(float(np.mean(per_target)))

plt.figure(figsize=(9,4))
plt.plot(n_list, avg_test, label="avg test accuracy (across targets)")
plt.title("MultiOutput RF - Avg Accuracy vs n_estimators")
plt.xlabel("n_estimators")
plt.ylabel("avg accuracy")
plt.ylim(0, 1.05)
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()